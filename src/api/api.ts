/* tslint:disable */
/* eslint-disable */
/**
 * Api Documentation
 * Api Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    recordStatus?: number;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {Post}
     * @memberof Comment
     */
    post?: Post;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    recordStatus?: number;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    contactType?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    recordStatus?: number;
    /**
     * 
     * @type {User}
     * @memberof Contact
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    recordStatus?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ModelAndView
     */
    model?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndViewStatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelAndViewStatusEnum {
    _100Continue = '100 CONTINUE',
    _101SwitchingProtocols = '101 SWITCHING_PROTOCOLS',
    _102Processing = '102 PROCESSING',
    _103Checkpoint = '103 CHECKPOINT',
    _200Ok = '200 OK',
    _201Created = '201 CREATED',
    _202Accepted = '202 ACCEPTED',
    _203NonAuthoritativeInformation = '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent = '204 NO_CONTENT',
    _205ResetContent = '205 RESET_CONTENT',
    _206PartialContent = '206 PARTIAL_CONTENT',
    _207MultiStatus = '207 MULTI_STATUS',
    _208AlreadyReported = '208 ALREADY_REPORTED',
    _226ImUsed = '226 IM_USED',
    _300MultipleChoices = '300 MULTIPLE_CHOICES',
    _301MovedPermanently = '301 MOVED_PERMANENTLY',
    _302Found = '302 FOUND',
    _302MovedTemporarily = '302 MOVED_TEMPORARILY',
    _303SeeOther = '303 SEE_OTHER',
    _304NotModified = '304 NOT_MODIFIED',
    _305UseProxy = '305 USE_PROXY',
    _307TemporaryRedirect = '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect = '308 PERMANENT_REDIRECT',
    _400BadRequest = '400 BAD_REQUEST',
    _401Unauthorized = '401 UNAUTHORIZED',
    _402PaymentRequired = '402 PAYMENT_REQUIRED',
    _403Forbidden = '403 FORBIDDEN',
    _404NotFound = '404 NOT_FOUND',
    _405MethodNotAllowed = '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable = '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired = '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout = '408 REQUEST_TIMEOUT',
    _409Conflict = '409 CONFLICT',
    _410Gone = '410 GONE',
    _411LengthRequired = '411 LENGTH_REQUIRED',
    _412PreconditionFailed = '412 PRECONDITION_FAILED',
    _413PayloadTooLarge = '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge = '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong = '414 URI_TOO_LONG',
    _414RequestUriTooLong = '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType = '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable = '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed = '417 EXPECTATION_FAILED',
    _418IAmATeapot = '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource = '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure = '420 METHOD_FAILURE',
    _421DestinationLocked = '421 DESTINATION_LOCKED',
    _422UnprocessableEntity = '422 UNPROCESSABLE_ENTITY',
    _423Locked = '423 LOCKED',
    _424FailedDependency = '424 FAILED_DEPENDENCY',
    _425TooEarly = '425 TOO_EARLY',
    _426UpgradeRequired = '426 UPGRADE_REQUIRED',
    _428PreconditionRequired = '428 PRECONDITION_REQUIRED',
    _429TooManyRequests = '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge = '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons = '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError = '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented = '501 NOT_IMPLEMENTED',
    _502BadGateway = '502 BAD_GATEWAY',
    _503ServiceUnavailable = '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout = '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported = '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates = '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage = '507 INSUFFICIENT_STORAGE',
    _508LoopDetected = '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded = '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended = '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired = '511 NETWORK_AUTHENTICATION_REQUIRED'
}

/**
 * 
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    body?: string;
    /**
     * 
     * @type {Category}
     * @memberof Post
     */
    category?: Category;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    datePosted?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Post
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    excerpt?: string;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Post
     */
    published?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    recordStatus?: number;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    title?: string;
    /**
     * 
     * @type {User}
     * @memberof Post
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    views?: number;
}
/**
 * 
 * @export
 * @interface PostPreview
 */
export interface PostPreview {
    /**
     * 
     * @type {Category}
     * @memberof PostPreview
     */
    category?: Category;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    excerpt?: string;
    /**
     * 
     * @type {number}
     * @memberof PostPreview
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {number}
     * @memberof PostPreview
     */
    recordStatus?: number;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    slug?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PostPreview
     */
    tags?: Array<Tag>;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    title?: string;
    /**
     * 
     * @type {User}
     * @memberof PostPreview
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof PostPreview
     */
    views?: number;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    recordStatus?: number;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    recordStatus?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    about?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    recordStatus?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateUsingPOST(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUsingPOST(options?: any): AxiosPromise<object> {
            return localVarFp.validateUsingPOST(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public validateUsingPOST(options?: any) {
        return AuthControllerApiFp(this.configuration).validateUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BasicErrorControllerApi - axios parameter creator
 * @export
 */
export const BasicErrorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasicErrorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingDELETE(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingDELETE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingHEAD(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingHEAD(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingOPTIONS(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingOPTIONS(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPATCH(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPATCH(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPOST(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPUT(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPUT(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasicErrorControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingDELETE(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingHEAD(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingOPTIONS(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPATCH(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPUT(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryById: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategoryById', 'categoryId', categoryId)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllCategories
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryById', 'categoryId', categoryId)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('saveCategory', 'category', category)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('updateCategory', 'category', category)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategoryById(categoryId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoryById(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllCategories
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(categoryId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryById(categoryId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllCategories
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(q?: string, sort?: string, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllCategories(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(categoryId: number, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.saveCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory(category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteCategoryById
     * @param {number} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deleteCategoryById(categoryId: number, options?: any) {
        return CategoryControllerApiFp(this.configuration).deleteCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllCategories
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getAllCategories(q?: string, sort?: string, options?: any) {
        return CategoryControllerApiFp(this.configuration).getAllCategories(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCategoryById
     * @param {number} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getCategoryById(categoryId: number, options?: any) {
        return CategoryControllerApiFp(this.configuration).getCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveCategory
     * @param {Category} category category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public saveCategory(category: Category, options?: any) {
        return CategoryControllerApiFp(this.configuration).saveCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateCategory
     * @param {Category} category category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updateCategory(category: Category, options?: any) {
        return CategoryControllerApiFp(this.configuration).updateCategory(category, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommentControllerApi - axios parameter creator
 * @export
 */
export const CommentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteCommentById
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommentById: async (commentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteCommentById', 'commentId', commentId)
            const localVarPath = `/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllComments
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComments: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCommentById
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentById: async (commentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('getCommentById', 'commentId', commentId)
            const localVarPath = `/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveComment
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveComment: async (comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('saveComment', 'comment', comment)
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateComment
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment: async (comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('updateComment', 'comment', comment)
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentControllerApi - functional programming interface
 * @export
 */
export const CommentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteCommentById
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommentById(commentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommentById(commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllComments
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllComments(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllComments(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getCommentById
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentById(commentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentById(commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveComment
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveComment(comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveComment(comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateComment
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComment(comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentControllerApi - factory interface
 * @export
 */
export const CommentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteCommentById
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommentById(commentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCommentById(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllComments
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComments(q?: string, sort?: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.getAllComments(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCommentById
         * @param {number} commentId commentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentById(commentId: number, options?: any): AxiosPromise<Comment> {
            return localVarFp.getCommentById(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveComment
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveComment(comment: Comment, options?: any): AxiosPromise<Comment> {
            return localVarFp.saveComment(comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateComment
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(comment: Comment, options?: any): AxiosPromise<Comment> {
            return localVarFp.updateComment(comment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentControllerApi - object-oriented interface
 * @export
 * @class CommentControllerApi
 * @extends {BaseAPI}
 */
export class CommentControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteCommentById
     * @param {number} commentId commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public deleteCommentById(commentId: number, options?: any) {
        return CommentControllerApiFp(this.configuration).deleteCommentById(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllComments
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public getAllComments(q?: string, sort?: string, options?: any) {
        return CommentControllerApiFp(this.configuration).getAllComments(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCommentById
     * @param {number} commentId commentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public getCommentById(commentId: number, options?: any) {
        return CommentControllerApiFp(this.configuration).getCommentById(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveComment
     * @param {Comment} comment comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public saveComment(comment: Comment, options?: any) {
        return CommentControllerApiFp(this.configuration).saveComment(comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateComment
     * @param {Comment} comment comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public updateComment(comment: Comment, options?: any) {
        return CommentControllerApiFp(this.configuration).updateComment(comment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactControllerApi - axios parameter creator
 * @export
 */
export const ContactControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactById: async (contactId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteContactById', 'contactId', contactId)
            const localVarPath = `/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllContacts
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactById: async (contactId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getContactById', 'contactId', contactId)
            const localVarPath = `/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveContact
         * @param {Contact} contact contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContact: async (contact: Contact, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('saveContact', 'contact', contact)
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateContact
         * @param {Contact} contact contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact: async (contact: Contact, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('updateContact', 'contact', contact)
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactControllerApi - functional programming interface
 * @export
 */
export const ContactControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContactById(contactId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContactById(contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllContacts
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContacts(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContacts(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactById(contactId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactById(contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveContact
         * @param {Contact} contact contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveContact(contact: Contact, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveContact(contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateContact
         * @param {Contact} contact contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContact(contact: Contact, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContact(contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactControllerApi - factory interface
 * @export
 */
export const ContactControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactById(contactId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContactById(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllContacts
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(q?: string, sort?: string, options?: any): AxiosPromise<Array<Contact>> {
            return localVarFp.getAllContacts(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactById(contactId: number, options?: any): AxiosPromise<Contact> {
            return localVarFp.getContactById(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveContact
         * @param {Contact} contact contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContact(contact: Contact, options?: any): AxiosPromise<Contact> {
            return localVarFp.saveContact(contact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateContact
         * @param {Contact} contact contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(contact: Contact, options?: any): AxiosPromise<Contact> {
            return localVarFp.updateContact(contact, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
export class ContactControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteContactById
     * @param {number} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public deleteContactById(contactId: number, options?: any) {
        return ContactControllerApiFp(this.configuration).deleteContactById(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllContacts
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getAllContacts(q?: string, sort?: string, options?: any) {
        return ContactControllerApiFp(this.configuration).getAllContacts(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getContactById
     * @param {number} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getContactById(contactId: number, options?: any) {
        return ContactControllerApiFp(this.configuration).getContactById(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveContact
     * @param {Contact} contact contact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public saveContact(contact: Contact, options?: any) {
        return ContactControllerApiFp(this.configuration).saveContact(contact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateContact
     * @param {Contact} contact contact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public updateContact(contact: Contact, options?: any) {
        return ContactControllerApiFp(this.configuration).updateContact(contact, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaControllerApi - axios parameter creator
 * @export
 */
export const MediaControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaById: async (mediaId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('deleteMediaById', 'mediaId', mediaId)
            const localVarPath = `/medias/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllMedias
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMedias: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/medias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaById: async (mediaId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaById', 'mediaId', mediaId)
            const localVarPath = `/medias/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveMedia: async (media: Media, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'media' is not null or undefined
            assertParamExists('saveMedia', 'media', media)
            const localVarPath = `/medias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(media, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedia: async (media: Media, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'media' is not null or undefined
            assertParamExists('updateMedia', 'media', media)
            const localVarPath = `/medias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(media, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaControllerApi - functional programming interface
 * @export
 */
export const MediaControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMediaById(mediaId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMediaById(mediaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllMedias
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMedias(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Media>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMedias(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaById(mediaId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaById(mediaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveMedia(media: Media, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveMedia(media, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMedia(media: Media, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMedia(media, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaControllerApi - factory interface
 * @export
 */
export const MediaControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaById(mediaId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMediaById(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllMedias
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMedias(q?: string, sort?: string, options?: any): AxiosPromise<Array<Media>> {
            return localVarFp.getAllMedias(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaById(mediaId: number, options?: any): AxiosPromise<Media> {
            return localVarFp.getMediaById(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveMedia(media: Media, options?: any): AxiosPromise<Media> {
            return localVarFp.saveMedia(media, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedia(media: Media, options?: any): AxiosPromise<Media> {
            return localVarFp.updateMedia(media, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaControllerApi - object-oriented interface
 * @export
 * @class MediaControllerApi
 * @extends {BaseAPI}
 */
export class MediaControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteMediaById
     * @param {number} mediaId mediaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public deleteMediaById(mediaId: number, options?: any) {
        return MediaControllerApiFp(this.configuration).deleteMediaById(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllMedias
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public getAllMedias(q?: string, sort?: string, options?: any) {
        return MediaControllerApiFp(this.configuration).getAllMedias(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getMediaById
     * @param {number} mediaId mediaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public getMediaById(mediaId: number, options?: any) {
        return MediaControllerApiFp(this.configuration).getMediaById(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveMedia
     * @param {Media} media media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public saveMedia(media: Media, options?: any) {
        return MediaControllerApiFp(this.configuration).saveMedia(media, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateMedia
     * @param {Media} media media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public updateMedia(media: Media, options?: any) {
        return MediaControllerApiFp(this.configuration).updateMedia(media, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostControllerApi - axios parameter creator
 * @export
 */
export const PostControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addPostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostTags: async (postId: number, tags: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('addPostTags', 'postId', postId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('addPostTags', 'tags', tags)
            const localVarPath = `/posts/{postId}/tags`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostById: async (postId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePostById', 'postId', postId)
            const localVarPath = `/posts/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostTags: async (postId: number, tags: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePostTags', 'postId', postId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('deletePostTags', 'tags', tags)
            const localVarPath = `/posts/{postId}/tags`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllPosts
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById: async (postId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPostById', 'postId', postId)
            const localVarPath = `/posts/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPostTags
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostTags: async (postId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPostTags', 'postId', postId)
            const localVarPath = `/posts/{postId}/tags`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary savePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePost: async (post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            assertParamExists('savePost', 'post', post)
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setPostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPostTags: async (postId: number, tags: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('setPostTags', 'postId', postId)
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('setPostTags', 'tags', tags)
            const localVarPath = `/posts/{postId}/tags`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost: async (post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            assertParamExists('updatePost', 'post', post)
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostControllerApi - functional programming interface
 * @export
 */
export const PostControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addPostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPostTags(postId: number, tags: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPostTags(postId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostById(postId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostById(postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostTags(postId: number, tags: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostTags(postId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllPosts
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPosts(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostById(postId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostById(postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPostTags
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostTags(postId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostTags(postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary savePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savePost(post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savePost(post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary setPostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPostTags(postId: number, tags: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPostTags(postId, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePost(post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostControllerApi - factory interface
 * @export
 */
export const PostControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addPostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPostTags(postId: number, tags: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.addPostTags(postId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostById(postId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePostById(postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostTags(postId: number, tags: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.deletePostTags(postId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllPosts
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.getAllPosts(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById(postId: number, options?: any): AxiosPromise<Post> {
            return localVarFp.getPostById(postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPostTags
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostTags(postId: number, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getPostTags(postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary savePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePost(post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.savePost(post, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setPostTags
         * @param {number} postId postId
         * @param {Array<Tag>} tags tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPostTags(postId: number, tags: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.setPostTags(postId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost(post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.updatePost(post, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostControllerApi - object-oriented interface
 * @export
 * @class PostControllerApi
 * @extends {BaseAPI}
 */
export class PostControllerApi extends BaseAPI {
    /**
     * 
     * @summary addPostTags
     * @param {number} postId postId
     * @param {Array<Tag>} tags tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public addPostTags(postId: number, tags: Array<Tag>, options?: any) {
        return PostControllerApiFp(this.configuration).addPostTags(postId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePostById
     * @param {number} postId postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public deletePostById(postId: number, options?: any) {
        return PostControllerApiFp(this.configuration).deletePostById(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePostTags
     * @param {number} postId postId
     * @param {Array<Tag>} tags tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public deletePostTags(postId: number, tags: Array<Tag>, options?: any) {
        return PostControllerApiFp(this.configuration).deletePostTags(postId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllPosts
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getAllPosts(page?: string, q?: string, sort?: string, options?: any) {
        return PostControllerApiFp(this.configuration).getAllPosts(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPostById
     * @param {number} postId postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getPostById(postId: number, options?: any) {
        return PostControllerApiFp(this.configuration).getPostById(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPostTags
     * @param {number} postId postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getPostTags(postId: number, options?: any) {
        return PostControllerApiFp(this.configuration).getPostTags(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary savePost
     * @param {Post} post post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public savePost(post: Post, options?: any) {
        return PostControllerApiFp(this.configuration).savePost(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setPostTags
     * @param {number} postId postId
     * @param {Array<Tag>} tags tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public setPostTags(postId: number, tags: Array<Tag>, options?: any) {
        return PostControllerApiFp(this.configuration).setPostTags(postId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePost
     * @param {Post} post post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public updatePost(post: Post, options?: any) {
        return PostControllerApiFp(this.configuration).updatePost(post, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostPreviewControllerApi - axios parameter creator
 * @export
 */
export const PostPreviewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAll
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsingGET: async (page?: string, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostPreviewControllerApi - functional programming interface
 * @export
 */
export const PostPreviewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostPreviewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getAll
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsingGET(page?: string, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostPreview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsingGET(page, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostPreviewControllerApi - factory interface
 * @export
 */
export const PostPreviewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostPreviewControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary getAll
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsingGET(page?: string, q?: string, options?: any): AxiosPromise<Array<PostPreview>> {
            return localVarFp.getAllUsingGET(page, q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostPreviewControllerApi - object-oriented interface
 * @export
 * @class PostPreviewControllerApi
 * @extends {BaseAPI}
 */
export class PostPreviewControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAll
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostPreviewControllerApi
     */
    public getAllUsingGET(page?: string, q?: string, options?: any) {
        return PostPreviewControllerApiFp(this.configuration).getAllUsingGET(page, q, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoleControllerApi - axios parameter creator
 * @export
 */
export const RoleControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleById: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRoleById', 'roleId', roleId)
            const localVarPath = `/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllUsers
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoleUsers: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getAllRoleUsers', 'roleId', roleId)
            const localVarPath = `/roles/{roleId}/users`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleById', 'roleId', roleId)
            const localVarPath = `/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('saveRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('updateRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleControllerApi - functional programming interface
 * @export
 */
export const RoleControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleById(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleById(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllUsers
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoleUsers(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoleUsers(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleById(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleById(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary save
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRole(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoleControllerApi - factory interface
 * @export
 */
export const RoleControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleById(roleId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleById(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllUsers
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoleUsers(roleId: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getAllRoleUsers(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById(roleId: number, options?: any): AxiosPromise<Role> {
            return localVarFp.getRoleById(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary save
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRole(role: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.saveRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(role: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.updateRole(role, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleControllerApi - object-oriented interface
 * @export
 * @class RoleControllerApi
 * @extends {BaseAPI}
 */
export class RoleControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteById
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public deleteRoleById(roleId: number, options?: any) {
        return RoleControllerApiFp(this.configuration).deleteRoleById(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllUsers
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getAllRoleUsers(roleId: number, options?: any) {
        return RoleControllerApiFp(this.configuration).getAllRoleUsers(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getAllRoles(options?: any) {
        return RoleControllerApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getById
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getRoleById(roleId: number, options?: any) {
        return RoleControllerApiFp(this.configuration).getRoleById(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary save
     * @param {Role} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public saveRole(role: Role, options?: any) {
        return RoleControllerApiFp(this.configuration).saveRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {Role} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public updateRole(role: Role, options?: any) {
        return RoleControllerApiFp(this.configuration).updateRole(role, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagControllerApi - axios parameter creator
 * @export
 */
export const TagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPosts: async (tagId: number, posts: Array<Post>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('addTagPosts', 'tagId', tagId)
            // verify required parameter 'posts' is not null or undefined
            assertParamExists('addTagPosts', 'posts', posts)
            const localVarPath = `/tags/{tagId}/posts`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagById: async (tagId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTagById', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagPosts: async (tagId: number, posts: Array<Post>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTagPosts', 'tagId', tagId)
            // verify required parameter 'posts' is not null or undefined
            assertParamExists('deleteTagPosts', 'posts', posts)
            const localVarPath = `/tags/{tagId}/posts`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllTags
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById: async (tagId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getTagById', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTagPosts
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagPosts: async (tagId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getTagPosts', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}/posts`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag: async (tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('saveTag', 'tag', tag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTagPosts: async (tagId: number, posts: Array<Post>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('setTagPosts', 'tagId', tagId)
            // verify required parameter 'posts' is not null or undefined
            assertParamExists('setTagPosts', 'posts', posts)
            const localVarPath = `/tags/{tagId}/posts`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('updateTag', 'tag', tag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagControllerApi - functional programming interface
 * @export
 */
export const TagControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagPosts(tagId: number, posts: Array<Post>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagPosts(tagId, posts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagById(tagId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagById(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagPosts(tagId: number, posts: Array<Post>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagPosts(tagId, posts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllTags
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagById(tagId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagById(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getTagPosts
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagPosts(tagId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagPosts(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTag(tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary setTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTagPosts(tagId: number, posts: Array<Post>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTagPosts(tagId, posts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagControllerApi - factory interface
 * @export
 */
export const TagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary addTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagPosts(tagId: number, posts: Array<Post>, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.addTagPosts(tagId, posts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagById(tagId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTagById(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagPosts(tagId: number, posts: Array<Post>, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.deleteTagPosts(tagId, posts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllTags
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(q?: string, sort?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getAllTags(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById(tagId: number, options?: any): AxiosPromise<Tag> {
            return localVarFp.getTagById(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTagPosts
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagPosts(tagId: number, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.getTagPosts(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag(tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.saveTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setTagPosts
         * @param {number} tagId tagId
         * @param {Array<Post>} posts posts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTagPosts(tagId: number, posts: Array<Post>, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.setTagPosts(tagId, posts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.updateTag(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagControllerApi - object-oriented interface
 * @export
 * @class TagControllerApi
 * @extends {BaseAPI}
 */
export class TagControllerApi extends BaseAPI {
    /**
     * 
     * @summary addTagPosts
     * @param {number} tagId tagId
     * @param {Array<Post>} posts posts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public addTagPosts(tagId: number, posts: Array<Post>, options?: any) {
        return TagControllerApiFp(this.configuration).addTagPosts(tagId, posts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteTagById
     * @param {number} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public deleteTagById(tagId: number, options?: any) {
        return TagControllerApiFp(this.configuration).deleteTagById(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteTagPosts
     * @param {number} tagId tagId
     * @param {Array<Post>} posts posts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public deleteTagPosts(tagId: number, posts: Array<Post>, options?: any) {
        return TagControllerApiFp(this.configuration).deleteTagPosts(tagId, posts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllTags
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public getAllTags(q?: string, sort?: string, options?: any) {
        return TagControllerApiFp(this.configuration).getAllTags(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTagById
     * @param {number} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public getTagById(tagId: number, options?: any) {
        return TagControllerApiFp(this.configuration).getTagById(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTagPosts
     * @param {number} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public getTagPosts(tagId: number, options?: any) {
        return TagControllerApiFp(this.configuration).getTagPosts(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveTag
     * @param {Tag} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public saveTag(tag: Tag, options?: any) {
        return TagControllerApiFp(this.configuration).saveTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setTagPosts
     * @param {number} tagId tagId
     * @param {Array<Post>} posts posts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public setTagPosts(tagId: number, posts: Array<Post>, options?: any) {
        return TagControllerApiFp(this.configuration).setTagPosts(tagId, posts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateTag
     * @param {Tag} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public updateTag(tag: Tag, options?: any) {
        return TagControllerApiFp(this.configuration).updateTag(tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllRoles
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserRoles: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllUserRoles', 'userId', userId)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllUsers
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getById
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('saveUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserById(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllRoles
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUserRoles(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUserRoles(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllUsers
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getById
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary save
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllRoles
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserRoles(userId: number, options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.getAllUserRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllUsers
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getAllUsers(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getById
         * @param {string} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary save
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.saveUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteById
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteUserById(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).deleteUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllRoles
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAllUserRoles(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).getAllUserRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllUsers
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAllUsers(page?: string, q?: string, sort?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getAllUsers(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getById
     * @param {string} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserById(userId: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary save
     * @param {User} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public saveUser(user: User, options?: any) {
        return UserControllerApiFp(this.configuration).saveUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {User} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateUser(user: User, options?: any) {
        return UserControllerApiFp(this.configuration).updateUser(user, options).then((request) => request(this.axios, this.basePath));
    }
}


