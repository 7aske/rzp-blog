/* tslint:disable */
/* eslint-disable */
/**
 * Api Documentation
 * Api Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    recordStatus?: CategoryRecordStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CategoryRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    confirm?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    previous?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    body?: string;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Comment
     */
    comments?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {Comment}
     * @memberof Comment
     */
    parent?: Comment;
    /**
     * 
     * @type {Post}
     * @memberof Comment
     */
    post?: Post;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    recordStatus?: CommentRecordStatusEnum;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    user?: User;
}

/**
    * @export
    * @enum {string}
    */
export enum CommentRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    contactType?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    recordStatus?: ContactRecordStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ContactRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    recordStatus?: MediaRecordStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    type?: MediaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    width?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum MediaRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}
/**
    * @export
    * @enum {string}
    */
export enum MediaTypeEnum {
    ProfileImage = 'PROFILE_IMAGE',
    PostImage = 'POST_IMAGE'
}

/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ModelAndView
     */
    model?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndViewStatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelAndViewStatusEnum {
    _100Continue = '100 CONTINUE',
    _101SwitchingProtocols = '101 SWITCHING_PROTOCOLS',
    _102Processing = '102 PROCESSING',
    _103Checkpoint = '103 CHECKPOINT',
    _200Ok = '200 OK',
    _201Created = '201 CREATED',
    _202Accepted = '202 ACCEPTED',
    _203NonAuthoritativeInformation = '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent = '204 NO_CONTENT',
    _205ResetContent = '205 RESET_CONTENT',
    _206PartialContent = '206 PARTIAL_CONTENT',
    _207MultiStatus = '207 MULTI_STATUS',
    _208AlreadyReported = '208 ALREADY_REPORTED',
    _226ImUsed = '226 IM_USED',
    _300MultipleChoices = '300 MULTIPLE_CHOICES',
    _301MovedPermanently = '301 MOVED_PERMANENTLY',
    _302Found = '302 FOUND',
    _302MovedTemporarily = '302 MOVED_TEMPORARILY',
    _303SeeOther = '303 SEE_OTHER',
    _304NotModified = '304 NOT_MODIFIED',
    _305UseProxy = '305 USE_PROXY',
    _307TemporaryRedirect = '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect = '308 PERMANENT_REDIRECT',
    _400BadRequest = '400 BAD_REQUEST',
    _401Unauthorized = '401 UNAUTHORIZED',
    _402PaymentRequired = '402 PAYMENT_REQUIRED',
    _403Forbidden = '403 FORBIDDEN',
    _404NotFound = '404 NOT_FOUND',
    _405MethodNotAllowed = '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable = '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired = '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout = '408 REQUEST_TIMEOUT',
    _409Conflict = '409 CONFLICT',
    _410Gone = '410 GONE',
    _411LengthRequired = '411 LENGTH_REQUIRED',
    _412PreconditionFailed = '412 PRECONDITION_FAILED',
    _413PayloadTooLarge = '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge = '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong = '414 URI_TOO_LONG',
    _414RequestUriTooLong = '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType = '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable = '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed = '417 EXPECTATION_FAILED',
    _418IAmATeapot = '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource = '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure = '420 METHOD_FAILURE',
    _421DestinationLocked = '421 DESTINATION_LOCKED',
    _422UnprocessableEntity = '422 UNPROCESSABLE_ENTITY',
    _423Locked = '423 LOCKED',
    _424FailedDependency = '424 FAILED_DEPENDENCY',
    _425TooEarly = '425 TOO_EARLY',
    _426UpgradeRequired = '426 UPGRADE_REQUIRED',
    _428PreconditionRequired = '428 PRECONDITION_REQUIRED',
    _429TooManyRequests = '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge = '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons = '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError = '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented = '501 NOT_IMPLEMENTED',
    _502BadGateway = '502 BAD_GATEWAY',
    _503ServiceUnavailable = '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout = '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported = '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates = '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage = '507 INSUFFICIENT_STORAGE',
    _508LoopDetected = '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded = '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended = '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired = '511 NETWORK_AUTHENTICATION_REQUIRED'
}

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    actionUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    read?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    recordStatus?: NotificationRecordStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    seen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    type?: string;
    /**
     * 
     * @type {User}
     * @memberof Notification
     */
    user?: User;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    body?: string;
    /**
     * 
     * @type {Category}
     * @memberof Post
     */
    category?: Category;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    datePosted?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    excerpt?: string;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Post
     */
    published?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    recordStatus?: PostRecordStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    slug?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Post
     */
    tags?: Array<Tag>;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    title?: string;
    /**
     * 
     * @type {User}
     * @memberof Post
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    views?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PostRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface PostPreview
 */
export interface PostPreview {
    /**
     * 
     * @type {Category}
     * @memberof PostPreview
     */
    category?: Category;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    excerpt?: string;
    /**
     * 
     * @type {number}
     * @memberof PostPreview
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostPreview
     */
    published?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    recordStatus?: PostPreviewRecordStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    slug?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PostPreview
     */
    tags?: Array<Tag>;
    /**
     * 
     * @type {string}
     * @memberof PostPreview
     */
    title?: string;
    /**
     * 
     * @type {User}
     * @memberof PostPreview
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof PostPreview
     */
    views?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PostPreviewRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface PostSummary
 */
export interface PostSummary {
    /**
     * 
     * @type {number}
     * @memberof PostSummary
     */
    count?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof PostSummary
     */
    summary?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface RegisterUserDto
 */
export interface RegisterUserDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserDto
     */
    confirm?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserDto
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserDto
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserDto
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserDto
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserDto
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    recordStatus?: RoleRecordStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RoleRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    recordStatus?: TagRecordStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TagRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    about?: string;
    /**
     * 
     * @type {Array<Contact>}
     * @memberof User
     */
    contacts?: Array<Contact>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {Media}
     * @memberof User
     */
    image?: Media;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastModifiedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    profileImage?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    recordStatus?: UserRecordStatusEnum;
    /**
     * 
     * @type {Array<Role>}
     * @memberof User
     */
    roles?: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserRecordStatusEnum {
    None = 'NONE',
    Active = 'ACTIVE',
    Expired = 'EXPIRED',
    Locked = 'LOCKED',
    Deleted = 'DELETED',
    Disabled = 'DISABLED'
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateUsingPOST(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUsingPOST(options?: any): AxiosPromise<object> {
            return localVarFp.validateUsingPOST(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public validateUsingPOST(options?: any) {
        return AuthControllerApiFp(this.configuration).validateUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BasicErrorControllerApi - axios parameter creator
 * @export
 */
export const BasicErrorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasicErrorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingDELETE(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingDELETE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingHEAD(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingHEAD(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingOPTIONS(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingOPTIONS(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPATCH(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPATCH(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPOST(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async errorHtmlUsingPUT(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAndView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.errorHtmlUsingPUT(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasicErrorControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingDELETE(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingHEAD(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingOPTIONS(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPATCH(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): AxiosPromise<ModelAndView> {
            return localVarFp.errorHtmlUsingPUT(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryById: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategoryById', 'categoryId', categoryId)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllCategories
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryById', 'categoryId', categoryId)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('saveCategory', 'category', category)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('updateCategory', 'category', category)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategoryById(categoryId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoryById(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllCategories
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(categoryId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryById(categoryId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllCategories
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(q?: string, sort?: string, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllCategories(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCategoryById
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(categoryId: number, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.saveCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateCategory
         * @param {Category} category category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory(category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteCategoryById
     * @param {number} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deleteCategoryById(categoryId: number, options?: any) {
        return CategoryControllerApiFp(this.configuration).deleteCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllCategories
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getAllCategories(q?: string, sort?: string, options?: any) {
        return CategoryControllerApiFp(this.configuration).getAllCategories(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCategoryById
     * @param {number} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getCategoryById(categoryId: number, options?: any) {
        return CategoryControllerApiFp(this.configuration).getCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveCategory
     * @param {Category} category category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public saveCategory(category: Category, options?: any) {
        return CategoryControllerApiFp(this.configuration).saveCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateCategory
     * @param {Category} category category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updateCategory(category: Category, options?: any) {
        return CategoryControllerApiFp(this.configuration).updateCategory(category, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactControllerApi - axios parameter creator
 * @export
 */
export const ContactControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactById: async (contactId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteContactById', 'contactId', contactId)
            const localVarPath = `/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllContactTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContactTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactControllerApi - functional programming interface
 * @export
 */
export const ContactControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContactById(contactId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContactById(contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllContactTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContactTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContactTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactControllerApi - factory interface
 * @export
 */
export const ContactControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteContactById
         * @param {number} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactById(contactId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContactById(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllContactTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContactTypes(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getAllContactTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
export class ContactControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteContactById
     * @param {number} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public deleteContactById(contactId: number, options?: any) {
        return ContactControllerApiFp(this.configuration).deleteContactById(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllContactTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getAllContactTypes(options?: any) {
        return ContactControllerApiFp(this.configuration).getAllContactTypes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaControllerApi - axios parameter creator
 * @export
 */
export const MediaControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaById: async (mediaId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('deleteMediaById', 'mediaId', mediaId)
            const localVarPath = `/medias/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllMedias
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMedias: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/medias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaById: async (mediaId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaById', 'mediaId', mediaId)
            const localVarPath = `/medias/{mediaId}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedia: async (media: Media, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'media' is not null or undefined
            assertParamExists('updateMedia', 'media', media)
            const localVarPath = `/medias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(media, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploadPostImage
         * @param {any} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPostImage: async (file?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/medias/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploadProfileImage
         * @param {any} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProfileImage: async (file?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/medias/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaControllerApi - functional programming interface
 * @export
 */
export const MediaControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMediaById(mediaId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMediaById(mediaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllMedias
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMedias(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Media>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMedias(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaById(mediaId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaById(mediaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMedia(media: Media, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMedia(media, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploadPostImage
         * @param {any} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPostImage(file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPostImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploadProfileImage
         * @param {any} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProfileImage(file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaControllerApi - factory interface
 * @export
 */
export const MediaControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaById(mediaId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMediaById(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllMedias
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMedias(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<Media>> {
            return localVarFp.getAllMedias(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getMediaById
         * @param {number} mediaId mediaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaById(mediaId: number, options?: any): AxiosPromise<Media> {
            return localVarFp.getMediaById(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateMedia
         * @param {Media} media media
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedia(media: Media, options?: any): AxiosPromise<Media> {
            return localVarFp.updateMedia(media, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploadPostImage
         * @param {any} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPostImage(file?: any, options?: any): AxiosPromise<Media> {
            return localVarFp.uploadPostImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploadProfileImage
         * @param {any} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProfileImage(file?: any, options?: any): AxiosPromise<Media> {
            return localVarFp.uploadProfileImage(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaControllerApi - object-oriented interface
 * @export
 * @class MediaControllerApi
 * @extends {BaseAPI}
 */
export class MediaControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteMediaById
     * @param {number} mediaId mediaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public deleteMediaById(mediaId: number, options?: any) {
        return MediaControllerApiFp(this.configuration).deleteMediaById(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllMedias
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public getAllMedias(page?: string, q?: string, sort?: string, options?: any) {
        return MediaControllerApiFp(this.configuration).getAllMedias(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getMediaById
     * @param {number} mediaId mediaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public getMediaById(mediaId: number, options?: any) {
        return MediaControllerApiFp(this.configuration).getMediaById(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateMedia
     * @param {Media} media media
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public updateMedia(media: Media, options?: any) {
        return MediaControllerApiFp(this.configuration).updateMedia(media, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploadPostImage
     * @param {any} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public uploadPostImage(file?: any, options?: any) {
        return MediaControllerApiFp(this.configuration).uploadPostImage(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploadProfileImage
     * @param {any} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaControllerApi
     */
    public uploadProfileImage(file?: any, options?: any) {
        return MediaControllerApiFp(this.configuration).uploadProfileImage(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationControllerApi - axios parameter creator
 * @export
 */
export const NotificationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary markAsRead
         * @param {number} notificationId notificationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead: async (notificationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('markAsRead', 'notificationId', notificationId)
            const localVarPath = `/notifications/{notificationId}/read`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationControllerApi - functional programming interface
 * @export
 */
export const NotificationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary markAsRead
         * @param {number} notificationId notificationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsRead(notificationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsRead(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationControllerApi - factory interface
 * @export
 */
export const NotificationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary markAsRead
         * @param {number} notificationId notificationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(notificationId: number, options?: any): AxiosPromise<void> {
            return localVarFp.markAsRead(notificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationControllerApi - object-oriented interface
 * @export
 * @class NotificationControllerApi
 * @extends {BaseAPI}
 */
export class NotificationControllerApi extends BaseAPI {
    /**
     * 
     * @summary markAsRead
     * @param {number} notificationId notificationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public markAsRead(notificationId: number, options?: any) {
        return NotificationControllerApiFp(this.configuration).markAsRead(notificationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostControllerApi - axios parameter creator
 * @export
 */
export const PostControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deletePostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostById: async (postId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePostById', 'postId', postId)
            const localVarPath = `/posts/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletePostCommentById
         * @param {number} commentId commentId
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostCommentById: async (commentId: number, postId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deletePostCommentById', 'commentId', commentId)
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('deletePostCommentById', 'postId', postId)
            const localVarPath = `/posts/{postId}/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllPostComments
         * @param {number} postId postId
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostComments: async (postId: number, page?: string, q?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getAllPostComments', 'postId', postId)
            const localVarPath = `/posts/{postId}/comments`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllPosts
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllPostsNotDeleted
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostsNotDeleted: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPostById
         * @param {string} identifier identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById: async (identifier: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getPostById', 'identifier', identifier)
            const localVarPath = `/posts/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPostSummary
         * @param {'TAG' | 'CATEGORY'} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostSummary: async (type: 'TAG' | 'CATEGORY', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getPostSummary', 'type', type)
            const localVarPath = `/posts/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary savePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePost: async (post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            assertParamExists('savePost', 'post', post)
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary savePostComment
         * @param {number} postId postId
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePostComment: async (postId: number, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('savePostComment', 'postId', postId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('savePostComment', 'comment', comment)
            const localVarPath = `/posts/{postId}/comments`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost: async (post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            assertParamExists('updatePost', 'post', post)
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePostComment
         * @param {number} postId postId
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostComment: async (postId: number, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('updatePostComment', 'postId', postId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('updatePostComment', 'comment', comment)
            const localVarPath = `/posts/{postId}/comments`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostControllerApi - functional programming interface
 * @export
 */
export const PostControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deletePostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostById(postId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostById(postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletePostCommentById
         * @param {number} commentId commentId
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostCommentById(commentId: number, postId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostCommentById(commentId, postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllPostComments
         * @param {number} postId postId
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPostComments(postId: number, page?: string, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPostComments(postId, page, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllPosts
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPosts(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllPostsNotDeleted
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPostsNotDeleted(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPostsNotDeleted(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPostById
         * @param {string} identifier identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostById(identifier: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostById(identifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPostSummary
         * @param {'TAG' | 'CATEGORY'} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostSummary(type: 'TAG' | 'CATEGORY', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostSummary(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary savePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savePost(post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savePost(post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary savePostComment
         * @param {number} postId postId
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savePostComment(postId: number, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savePostComment(postId, comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePost(post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePostComment
         * @param {number} postId postId
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePostComment(postId: number, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePostComment(postId, comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostControllerApi - factory interface
 * @export
 */
export const PostControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deletePostById
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostById(postId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePostById(postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletePostCommentById
         * @param {number} commentId commentId
         * @param {number} postId postId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostCommentById(commentId: number, postId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePostCommentById(commentId, postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllPostComments
         * @param {number} postId postId
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostComments(postId: number, page?: string, q?: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.getAllPostComments(postId, page, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllPosts
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.getAllPosts(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllPostsNotDeleted
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostsNotDeleted(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<Post>> {
            return localVarFp.getAllPostsNotDeleted(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPostById
         * @param {string} identifier identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById(identifier: string, options?: any): AxiosPromise<Post> {
            return localVarFp.getPostById(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPostSummary
         * @param {'TAG' | 'CATEGORY'} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostSummary(type: 'TAG' | 'CATEGORY', options?: any): AxiosPromise<PostSummary> {
            return localVarFp.getPostSummary(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary savePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePost(post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.savePost(post, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary savePostComment
         * @param {number} postId postId
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePostComment(postId: number, comment: Comment, options?: any): AxiosPromise<Comment> {
            return localVarFp.savePostComment(postId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePost
         * @param {Post} post post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost(post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.updatePost(post, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePostComment
         * @param {number} postId postId
         * @param {Comment} comment comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostComment(postId: number, comment: Comment, options?: any): AxiosPromise<Comment> {
            return localVarFp.updatePostComment(postId, comment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostControllerApi - object-oriented interface
 * @export
 * @class PostControllerApi
 * @extends {BaseAPI}
 */
export class PostControllerApi extends BaseAPI {
    /**
     * 
     * @summary deletePostById
     * @param {number} postId postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public deletePostById(postId: number, options?: any) {
        return PostControllerApiFp(this.configuration).deletePostById(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletePostCommentById
     * @param {number} commentId commentId
     * @param {number} postId postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public deletePostCommentById(commentId: number, postId: number, options?: any) {
        return PostControllerApiFp(this.configuration).deletePostCommentById(commentId, postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllPostComments
     * @param {number} postId postId
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getAllPostComments(postId: number, page?: string, q?: string, options?: any) {
        return PostControllerApiFp(this.configuration).getAllPostComments(postId, page, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllPosts
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getAllPosts(page?: string, q?: string, sort?: string, options?: any) {
        return PostControllerApiFp(this.configuration).getAllPosts(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllPostsNotDeleted
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getAllPostsNotDeleted(page?: string, q?: string, sort?: string, options?: any) {
        return PostControllerApiFp(this.configuration).getAllPostsNotDeleted(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPostById
     * @param {string} identifier identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getPostById(identifier: string, options?: any) {
        return PostControllerApiFp(this.configuration).getPostById(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPostSummary
     * @param {'TAG' | 'CATEGORY'} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public getPostSummary(type: 'TAG' | 'CATEGORY', options?: any) {
        return PostControllerApiFp(this.configuration).getPostSummary(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary savePost
     * @param {Post} post post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public savePost(post: Post, options?: any) {
        return PostControllerApiFp(this.configuration).savePost(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary savePostComment
     * @param {number} postId postId
     * @param {Comment} comment comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public savePostComment(postId: number, comment: Comment, options?: any) {
        return PostControllerApiFp(this.configuration).savePostComment(postId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePost
     * @param {Post} post post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public updatePost(post: Post, options?: any) {
        return PostControllerApiFp(this.configuration).updatePost(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePostComment
     * @param {number} postId postId
     * @param {Comment} comment comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostControllerApi
     */
    public updatePostComment(postId: number, comment: Comment, options?: any) {
        return PostControllerApiFp(this.configuration).updatePostComment(postId, comment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostPreviewControllerApi - axios parameter creator
 * @export
 */
export const PostPreviewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllPostPreviews
         * @param {string} [page] page
         * @param {string} [sort] sort
         * @param {string} [specification] specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostPreviews: async (page?: string, sort?: string, specification?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/previews/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (specification !== undefined) {
                localVarQueryParameter['specification'] = specification;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllPostPreviewsNotDeleted
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostPreviewsNotDeleted: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setRecordStatus
         * @param {number} postId postId
         * @param {'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED'} recordStatus recordStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecordStatus: async (postId: number, recordStatus: 'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('setRecordStatus', 'postId', postId)
            // verify required parameter 'recordStatus' is not null or undefined
            assertParamExists('setRecordStatus', 'recordStatus', recordStatus)
            const localVarPath = `/previews/{postId}/record-status`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (recordStatus !== undefined) {
                localVarQueryParameter['recordStatus'] = recordStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostPreviewControllerApi - functional programming interface
 * @export
 */
export const PostPreviewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostPreviewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getAllPostPreviews
         * @param {string} [page] page
         * @param {string} [sort] sort
         * @param {string} [specification] specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPostPreviews(page?: string, sort?: string, specification?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostPreview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPostPreviews(page, sort, specification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllPostPreviewsNotDeleted
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPostPreviewsNotDeleted(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostPreview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPostPreviewsNotDeleted(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary setRecordStatus
         * @param {number} postId postId
         * @param {'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED'} recordStatus recordStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRecordStatus(postId: number, recordStatus: 'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPreview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRecordStatus(postId, recordStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostPreviewControllerApi - factory interface
 * @export
 */
export const PostPreviewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostPreviewControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary getAllPostPreviews
         * @param {string} [page] page
         * @param {string} [sort] sort
         * @param {string} [specification] specification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostPreviews(page?: string, sort?: string, specification?: string, options?: any): AxiosPromise<Array<PostPreview>> {
            return localVarFp.getAllPostPreviews(page, sort, specification, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllPostPreviewsNotDeleted
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPostPreviewsNotDeleted(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<PostPreview>> {
            return localVarFp.getAllPostPreviewsNotDeleted(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setRecordStatus
         * @param {number} postId postId
         * @param {'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED'} recordStatus recordStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecordStatus(postId: number, recordStatus: 'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED', options?: any): AxiosPromise<PostPreview> {
            return localVarFp.setRecordStatus(postId, recordStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostPreviewControllerApi - object-oriented interface
 * @export
 * @class PostPreviewControllerApi
 * @extends {BaseAPI}
 */
export class PostPreviewControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllPostPreviews
     * @param {string} [page] page
     * @param {string} [sort] sort
     * @param {string} [specification] specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostPreviewControllerApi
     */
    public getAllPostPreviews(page?: string, sort?: string, specification?: string, options?: any) {
        return PostPreviewControllerApiFp(this.configuration).getAllPostPreviews(page, sort, specification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllPostPreviewsNotDeleted
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostPreviewControllerApi
     */
    public getAllPostPreviewsNotDeleted(page?: string, q?: string, sort?: string, options?: any) {
        return PostPreviewControllerApiFp(this.configuration).getAllPostPreviewsNotDeleted(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setRecordStatus
     * @param {number} postId postId
     * @param {'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED'} recordStatus recordStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostPreviewControllerApi
     */
    public setRecordStatus(postId: number, recordStatus: 'NONE' | 'ACTIVE' | 'EXPIRED' | 'LOCKED' | 'DELETED' | 'DISABLED', options?: any) {
        return PostPreviewControllerApiFp(this.configuration).setRecordStatus(postId, recordStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoleControllerApi - axios parameter creator
 * @export
 */
export const RoleControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleById: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRoleById', 'roleId', roleId)
            const localVarPath = `/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllUsers
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoleUsers: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getAllRoleUsers', 'roleId', roleId)
            const localVarPath = `/roles/{roleId}/users`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById: async (roleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleById', 'roleId', roleId)
            const localVarPath = `/roles/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('saveRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('updateRole', 'role', role)
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleControllerApi - functional programming interface
 * @export
 */
export const RoleControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleById(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleById(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllUsers
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoleUsers(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoleUsers(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleById(roleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleById(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary save
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRole(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoleControllerApi - factory interface
 * @export
 */
export const RoleControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleById(roleId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleById(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllUsers
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoleUsers(roleId: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getAllRoleUsers(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getById
         * @param {number} roleId roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById(roleId: number, options?: any): AxiosPromise<Role> {
            return localVarFp.getRoleById(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary save
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRole(role: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.saveRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {Role} role role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(role: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.updateRole(role, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleControllerApi - object-oriented interface
 * @export
 * @class RoleControllerApi
 * @extends {BaseAPI}
 */
export class RoleControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteById
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public deleteRoleById(roleId: number, options?: any) {
        return RoleControllerApiFp(this.configuration).deleteRoleById(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllUsers
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getAllRoleUsers(roleId: number, options?: any) {
        return RoleControllerApiFp(this.configuration).getAllRoleUsers(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getAllRoles(options?: any) {
        return RoleControllerApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getById
     * @param {number} roleId roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public getRoleById(roleId: number, options?: any) {
        return RoleControllerApiFp(this.configuration).getRoleById(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary save
     * @param {Role} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public saveRole(role: Role, options?: any) {
        return RoleControllerApiFp(this.configuration).saveRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {Role} role role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleControllerApi
     */
    public updateRole(role: Role, options?: any) {
        return RoleControllerApiFp(this.configuration).updateRole(role, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagControllerApi - axios parameter creator
 * @export
 */
export const TagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagById: async (tagId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTagById', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllTags
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById: async (tagId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getTagById', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag: async (tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('saveTag', 'tag', tag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('updateTag', 'tag', tag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagControllerApi - functional programming interface
 * @export
 */
export const TagControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagById(tagId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagById(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllTags
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagById(tagId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagById(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary saveTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTag(tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagControllerApi - factory interface
 * @export
 */
export const TagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagById(tagId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTagById(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllTags
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(q?: string, sort?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getAllTags(q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTagById
         * @param {number} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagById(tagId: number, options?: any): AxiosPromise<Tag> {
            return localVarFp.getTagById(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag(tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.saveTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateTag
         * @param {Tag} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.updateTag(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagControllerApi - object-oriented interface
 * @export
 * @class TagControllerApi
 * @extends {BaseAPI}
 */
export class TagControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteTagById
     * @param {number} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public deleteTagById(tagId: number, options?: any) {
        return TagControllerApiFp(this.configuration).deleteTagById(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllTags
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public getAllTags(q?: string, sort?: string, options?: any) {
        return TagControllerApiFp(this.configuration).getAllTags(q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTagById
     * @param {number} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public getTagById(tagId: number, options?: any) {
        return TagControllerApiFp(this.configuration).getTagById(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveTag
     * @param {Tag} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public saveTag(tag: Tag, options?: any) {
        return TagControllerApiFp(this.configuration).saveTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateTag
     * @param {Tag} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public updateTag(tag: Tag, options?: any) {
        return TagControllerApiFp(this.configuration).updateTag(tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary disableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('disableUser', 'userId', userId)
            const localVarPath = `/users/{userId}/enable`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary enableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('enableUser', 'userId', userId)
            const localVarPath = `/users/{userId}/enable`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllRoles
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserRoles: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllUserRoles', 'userId', userId)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllUsers
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (page?: string, q?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getNotificationsForUser
         * @param {boolean} [all] all
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsForUser: async (all?: boolean, page?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getById
         * @param {string} identifier identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (identifier: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUserById', 'identifier', identifier)
            const localVarPath = `/users/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {RegisterUserDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (dto: RegisterUserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('registerUser', 'dto', dto)
            const localVarPath = `/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resetUserPassword
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('resetUserPassword', 'userId', userId)
            const localVarPath = `/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('saveUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateUserPassword
         * @param {ChangePasswordDto} passwordDto passwordDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (passwordDto: ChangePasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordDto' is not null or undefined
            assertParamExists('updateUserPassword', 'passwordDto', passwordDto)
            const localVarPath = `/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserById(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary disableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary enableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllRoles
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUserRoles(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUserRoles(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllUsers
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(page?: string, q?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(page, q, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getNotificationsForUser
         * @param {boolean} [all] all
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsForUser(all?: boolean, page?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationsForUser(all, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getById
         * @param {string} identifier identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(identifier: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(identifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary save
         * @param {RegisterUserDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(dto: RegisterUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(dto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary resetUserPassword
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUserPassword(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUserPassword(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary save
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateUserPassword
         * @param {ChangePasswordDto} passwordDto passwordDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(passwordDto: ChangePasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(passwordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary deleteById
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary disableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableUser(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.disableUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary enableUser
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableUser(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.enableUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllRoles
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserRoles(userId: number, options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.getAllUserRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllUsers
         * @param {string} [page] page
         * @param {string} [q] q
         * @param {string} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(page?: string, q?: string, sort?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getAllUsers(page, q, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getNotificationsForUser
         * @param {boolean} [all] all
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsForUser(all?: boolean, page?: string, options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.getNotificationsForUser(all, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getById
         * @param {string} identifier identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(identifier: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary save
         * @param {RegisterUserDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(dto: RegisterUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.registerUser(dto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary resetUserPassword
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(userId: number, options?: any): AxiosPromise<User> {
            return localVarFp.resetUserPassword(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary save
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.saveUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {User} user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateUserPassword
         * @param {ChangePasswordDto} passwordDto passwordDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(passwordDto: ChangePasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(passwordDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteById
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteUserById(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).deleteUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary disableUser
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public disableUser(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).disableUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary enableUser
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public enableUser(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).enableUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllRoles
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAllUserRoles(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).getAllUserRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllUsers
     * @param {string} [page] page
     * @param {string} [q] q
     * @param {string} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAllUsers(page?: string, q?: string, sort?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getAllUsers(page, q, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getNotificationsForUser
     * @param {boolean} [all] all
     * @param {string} [page] page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getNotificationsForUser(all?: boolean, page?: string, options?: any) {
        return UserControllerApiFp(this.configuration).getNotificationsForUser(all, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getById
     * @param {string} identifier identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserById(identifier: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserById(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary save
     * @param {RegisterUserDto} dto dto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public registerUser(dto: RegisterUserDto, options?: any) {
        return UserControllerApiFp(this.configuration).registerUser(dto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary resetUserPassword
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public resetUserPassword(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).resetUserPassword(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary save
     * @param {User} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public saveUser(user: User, options?: any) {
        return UserControllerApiFp(this.configuration).saveUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {User} user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateUser(user: User, options?: any) {
        return UserControllerApiFp(this.configuration).updateUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateUserPassword
     * @param {ChangePasswordDto} passwordDto passwordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateUserPassword(passwordDto: ChangePasswordDto, options?: any) {
        return UserControllerApiFp(this.configuration).updateUserPassword(passwordDto, options).then((request) => request(this.axios, this.basePath));
    }
}


